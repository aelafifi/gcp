#!/usr/bin/python
# -*- coding: utf-8 -*-

"""
gcp: Goffi's CoPier
Copyright (C) 2010  Jérôme Poisson (goffi@goffi.org)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

### logging ###
import logging
from logging import debug, info, error, warning
logging.basicConfig(level=logging.DEBUG,
                    format='%(message)s')
###
import sys
import os,os.path
from optparse import OptionParser #To be replaced by argparse ASAP
import cPickle as pickle
try:
    import gobject
    #DBus
    import dbus, dbus.glib
    import dbus.service
    import dbus.mainloop.glib
except ImportError,e:
    error("Error during import")
    error("Please check dependecies:",e)
    exit(2)
try:
    from progressbar import ProgressBar, Percentage, Bar, ETA, FileTransferSpeed
    pbar_available=True
except ImportError, e:
    info ('ProgressBar not available, please download it at http://pypi.python.org/pypi/progressbar')
    info ('Progress bar deactivated\n--\n')
    pbar_available=False

NAME = "gcp (Goffi's copier)"
NAME_SHORT = "gcp"
VERSION = '0.1'

ABOUT = NAME+" v"+VERSION+""" (c) Jérôme Poisson (aka Goffi) 2010

---
"""+NAME+""" Copyright (C) 2010  Jérôme Poisson
This program comes with ABSOLUTELY NO WARRANTY;
This is free software, and you are welcome to redistribute it
under certain conditions.
---

This software is an advanced file copier
Get the latest version at http://www.goffi.org
"""

const_DBUS_INTERFACE = "org.goffi.gcp" 
const_DBUS_PATH = "/org/goffi/gcp" 


class DbusObject(dbus.service.Object):

    def __init__(self, gcp, bus, path):
        self._gcp = gcp
        dbus.service.Object.__init__(self, bus, path)
        debug("Init DbusObject...")
        self.cb={}
    
    @dbus.service.method(const_DBUS_INTERFACE,
                         in_signature='', out_signature='s')
    def getVersion(self):
        """Get gcp version
        @return: version as string"""
        return VERSION

    @dbus.service.method(const_DBUS_INTERFACE,
                         in_signature='ss', out_signature='bs')
    def addArgs(self, source_path, args):
        """Add arguments to gcp as if there were entered on its own command line
        @param source_path: current working dir to use as base for arguments, as given by os.getcwd()
        @param args: serialized (wich pickle) list of strings - without command name -, as given by sys.argv[1:].
        @return: success (boolean) and error message if any (string)"""
        try:
            args = pickle.loads(str(args))
        except TypeError, pickle.UnpicklingError:
            return (False, "INTERNAL ERROR: invalid arguments")
        return self._gcp.parseArguments(args, source_path)

class GCP():

    def __init__(self):
        try:
            sessions_bus = dbus.SessionBus()
            db_object = sessions_bus.get_object(const_DBUS_INTERFACE,
                                const_DBUS_PATH)
            self.gcp_main = dbus.Interface(db_object,
                                dbus_interface=const_DBUS_INTERFACE)
            self._main_instance = False

        except dbus.exceptions.DBusException,e:
            if e._dbus_error_name=='org.freedesktop.DBus.Error.ServiceUnknown':
                self.launchDbusMainInstance()
                debug ("gcp launched")
                self._main_instance = True
            else:
                raise e

    def launchDbusMainInstance(self):
        debug ("Init DBus...")
        session_bus = dbus.SessionBus()
        self.dbus_name = dbus.service.BusName(const_DBUS_INTERFACE, session_bus)
        self.dbus_object = DbusObject(self, session_bus, const_DBUS_PATH)

        self.copy_list = []
        self.mounts = self.__getMountPoints()
        self.files_left = 0
        self.bytes_left = 0

    def getFsType(self, path):
        fs=''
        for mount in self.mounts:
            if path.startswith(mount) and len(self.mounts[mount])>=len(fs):
                fs = self.mounts[mount]
        return fs

    def __getMountPoints(self):
        """Parse /proc/mounts to get currently mounted devices"""
        #TODO: reparse when a new device is added/a device is removed
        #(check freedesktop mounting signals)
        ret =  {}
        try:
            with open("/proc/mounts",'r') as mounts:
                for line in mounts.readlines():
                   fs_spec, fs_file, fs_vfstype, fs_mntops, fs_freq, fs_passno = line.split(' ')
                   ret[fs_file] = fs_vfstype
        except:
            error ("Can't read mounts table")
        return ret

    def __appendToList(self, path, destpath, options):
        """Add a file to the copy list
        @param path: absolute path of file
        @param options: options as return by optparse"""
        debug ("Adding to copy list: %s ==> %s (%s)", path, destpath, self.getFsType(destpath))
        try:
            self.bytes_left+=os.path.getsize(path)
            self.files_left+=1
            self.copy_list.append((path, destpath, options))
            print "total size:", float(self.bytes_left/1024/1024), "Mb (%i)" % self.files_left
        except OSError,e:
            error("Can't copy %(path)s: %(exception)s" % {'path':path, 'exception':e.strerror})


    def __appendDirToList(self, dirpath, destpath, options):
        """Add recursively directory to the copy list
        @param path: absolute path of dir
        @param options: options as return by optparse"""
        try:
            for filename in os.listdir(dirpath):
                filepath = os.path.join(dirpath,filename)
                if os.path.isdir(filepath):
                    full_destpath = os.path.join(destpath,filename)
                    self.__appendDirToList(filepath, full_destpath, options)
                else:
                    self.__appendToList(filepath, destpath, options)
        except OSError,e:
            error("Can't copy %(path)s: %(exception)s" % {'path':dirpath, 'exception':e.strerror})

    def __checkArgs(self, options, source_path, args):
        """Check thats args are files, and add them to copy list"""
        assert(len (args)>=2)
        try:
            destpath = os.path.normpath(os.path.join(os.path.expanduser(source_path), args.pop()))
        except OSError,e:
            error ("Invalid destpath: %s",e)
        
        for path in args:
            abspath = os.path.normpath(os.path.join(os.path.expanduser(source_path), path))
            if not os.path.exists(abspath):
                warning("The path given in arg doesn't exist or is not accessible: %s",abspath)
            else:
                if os.path.isdir(abspath):
                    full_destpath = destpath if os.path.isabs(path) else os.path.normpath(os.path.join(destpath, path))
                    if not options.recursive:
                        warning ('omitting directory "%s"' % abspath)
                    else:
                        self.__appendDirToList(abspath, full_destpath, options)
                else:
                    self.__appendToList(abspath, destpath, options)


    def parseArguments(self, full_args=sys.argv[1:], source_path = os.getcwd()):
        """Parse arguments and add files to queue
        @param full_args: list of arguments strings (without program name)
        @param source_path: path from where the arguments come, ad given by os.getcwd()
        @return: a tuple (boolean, message) where the boolean is the success of the arguments
                 validation, and message is the error message to print when necessary"""
        _usage="""
        %prog [options] FILE1 [FILE2 ...] DEST

        %prog --help for options list
        """
        for idx in range(len(full_args)):
            if isinstance(full_args[idx], unicode):
                #We don't want unicode as some filenames can be invalid unicode
                full_args[idx] = full_args[idx].encode('utf-8')
        
        parser = OptionParser(usage=_usage,version=ABOUT)

        parser.add_option("-r", "--recursive", action="store_true", default=False,
                    help="copy directories recursively")
        
        parser.add_option("--no-unicode-fix", action="store_true", default=False,
                    help="don't fixe name encoding errors") #TODO
        (options, args) = parser.parse_args(full_args)
        
        if not self._main_instance:
            info ("There is already one instance of %s running, pluging to it" % NAME_SHORT)
            #XXX: we have to serialize data as dbus only accept valid unicode, and filenames
            #     can have invalid unicode.
            return self.gcp_main.addArgs(os.getcwd(),pickle.dumps(full_args))
        else:
            if len(args) < 2:
                _error_msg = "Wrong number of arguments"
                return (False, _error_msg)
            debug("adding args to gcp: %s",args)
            self.__checkArgs(options, source_path, args)
        return (True,'')

    def go(self):
        """Launch main loop"""
        self.loop = gobject.MainLoop()
        try:
            self.loop.run()
        except KeyboardInterrupt:
            info("User interruption: good bye")


if __name__ == "__main__":
    gcp = GCP()
    success,message = gcp.parseArguments()
    if not success:
        error(message)
        exit(1)
    if gcp._main_instance:
        gcp.go()

