#!/usr/bin/python
# -*- coding: utf-8 -*-

"""
gcp: Goffi's CoPier
Copyright (C) 2010  Jérôme Poisson (goffi@goffi.org)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

### logging ###
import logging
from logging import debug, info, error, warning
logging.basicConfig(level=logging.INFO,
                    format='%(message)s')
###

import gettext
gettext.install('gcp', "i18n", unicode=True)

import sys
import os,os.path
from optparse import OptionParser #To be replaced by argparse ASAP
import cPickle as pickle
try:
    import gobject
    #DBus
    import dbus, dbus.glib
    import dbus.service
    import dbus.mainloop.glib
except ImportError,e:
    error(_("Error during import"))
    error(_("Please check dependecies:"),e)
    exit(2)
try:
    from progressbar import ProgressBar, Percentage, Bar, ETA, FileTransferSpeed
    pbar_available=True
except ImportError, e:
    info (_('ProgressBar not available, please download it at http://pypi.python.org/pypi/progressbar'))
    info (_('Progress bar deactivated\n--\n'))
    pbar_available=False

NAME = "gcp (Goffi's copier)"
NAME_SHORT = "gcp"
VERSION = '0.1'

ABOUT = NAME+u" v"+VERSION+u""" (c) Jérôme Poisson (aka Goffi) 2010

---
"""+NAME+u""" Copyright (C) 2010  Jérôme Poisson
""" + _(u"""This program comes with ABSOLUTELY NO WARRANTY;
This is free software, and you are welcome to redistribute it
under certain conditions.
---

This software is an advanced file copier
Get the latest version at http://www.goffi.org
""")

const_DBUS_INTERFACE = "org.goffi.gcp" 
const_DBUS_PATH = "/org/goffi/gcp"
const_BUFF_SIZE = 4096
const_PRESERVE = set(['mode','ownership','timestamps'])
const_JOURNAL_PATH = "~/.gcp_journal"


class DbusObject(dbus.service.Object):

    def __init__(self, gcp, bus, path):
        self._gcp = gcp
        dbus.service.Object.__init__(self, bus, path)
        debug(_("Init DbusObject..."))
        self.cb={}
    
    @dbus.service.method(const_DBUS_INTERFACE,
                         in_signature='', out_signature='s')
    def getVersion(self):
        """Get gcp version
        @return: version as string"""
        return VERSION

    @dbus.service.method(const_DBUS_INTERFACE,
                         in_signature='ss', out_signature='bs')
    def addArgs(self, source_path, args):
        """Add arguments to gcp as if there were entered on its own command line
        @param source_path: current working dir to use as base for arguments, as given by os.getcwd()
        @param args: serialized (wich pickle) list of strings - without command name -, as given by sys.argv[1:].
        @return: success (boolean) and error message if any (string)"""
        try:
            args = pickle.loads(str(args))
        except TypeError, pickle.UnpicklingError:
            return (False, _("INTERNAL ERROR: invalid arguments"))
        return self._gcp.parseArguments(args, source_path)

class Journal():
    def __init__(self, path=const_JOURNAL_PATH):
        self.journal_path = os.path.expanduser(path)
        self.journal_fd = open(self.journal_path,'w') #TODO: check and maybe save previous journals

    def __del__(self):
        self.journal_fd.flush()
        self.journal_fd.close()

    def startFile(self, source_path):
        """Start an entry in the journal"""
        self.journal_fd.write(source_path+"\n")
        self.journal_fd.flush()
        self.success=True
        self.errors=[]

    def closeFile(self):
        """Close the entry in the journal"""
        if not self.success:
            status = "FAILED"
        else:
            status = "OK" if not self.errors else "PARTIAL"
        self.journal_fd.write("%(status)s: %(errors)s\n" % {'status': status, 'errors': ', '.join(self.errors)})
        self.journal_fd.flush()

    def copyFailed(self):
        """Must be called when something is wrong with the copy itself"""
        self.success = False

    def error(self, name):
        """Something went wrong"""
        self.errors.append(name)
        

class GCP():

    def __init__(self):
        try:
            sessions_bus = dbus.SessionBus()
            db_object = sessions_bus.get_object(const_DBUS_INTERFACE,
                                const_DBUS_PATH)
            self.gcp_main = dbus.Interface(db_object,
                                dbus_interface=const_DBUS_INTERFACE)
            self._main_instance = False

        except dbus.exceptions.DBusException,e:
            if e._dbus_error_name=='org.freedesktop.DBus.Error.ServiceUnknown':
                self.launchDbusMainInstance()
                debug (_("gcp launched"))
                self._main_instance = True
                self.buffer_size = const_BUFF_SIZE
            else:
                raise e

    def launchDbusMainInstance(self):
        debug (_("Init DBus..."))
        session_bus = dbus.SessionBus()
        self.dbus_name = dbus.service.BusName(const_DBUS_INTERFACE, session_bus)
        self.dbus_object = DbusObject(self, session_bus, const_DBUS_PATH)

        self.copy_list = []
        self.mounts = self.__getMountPoints()
        self.bytes_total = 0
        self.bytes_copied = 0

    def getFsType(self, path):
        fs = ''
        last_mount_point = ''
        for mount in self.mounts:
            if path.startswith(mount) and len(mount)>=len(last_mount_point):
                fs = self.mounts[mount]
                last_mount_point = mount
        return fs

    def __getMountPoints(self):
        """Parse /proc/mounts to get currently mounted devices"""
        #TODO: reparse when a new device is added/a device is removed
        #(check freedesktop mounting signals)
        ret =  {}
        try:
            with open("/proc/mounts",'rb') as mounts:
                for line in mounts.readlines():
                   fs_spec, fs_file, fs_vfstype, fs_mntops, fs_freq, fs_passno = line.split(' ')
                   ret[fs_file] = fs_vfstype
        except:
            error (_("Can't read mounts table"))
        return ret

    def __appendToList(self, path, dest_path, options):
        """Add a file to the copy list
        @param path: absolute path of file
        @param options: options as return by optparse"""
        debug ("Adding to copy list: %(path)s ==> %(dest_path)s (%(fs_type)s)" % {"path":path,
                                                                                  "dest_path":dest_path,
                                                                                   "fs_type":self.getFsType(dest_path)}              )
        try:
            self.bytes_total+=os.path.getsize(path)
            self.copy_list.insert(0,(path, dest_path, options))
        except OSError,e:
            error(_("Can't copy %(path)s: %(exception)s") % {'path':path, 'exception':e.strerror})


    def __appendDirToList(self, dirpath, dest_path, options):
        """Add recursively directory to the copy list
        @param path: absolute path of dir
        @param options: options as return by optparse"""
        #We first check that the dest path exists, and create it if needed
        dest_path = self.__filename_fix(dest_path, options)
        if not os.path.exists(dest_path):
            debug (_("Creating directory %s") % dest_path)
            os.makedirs(dest_path) #TODO: check permissions
        #TODO: check that dest_path is an accessible dir,
        #      and skip file/write error in log if needed
        try:
            for filename in os.listdir(dirpath):
                filepath = os.path.join(dirpath,filename)
                if os.path.isdir(filepath):
                    full_dest_path = os.path.join(dest_path,filename)
                    self.__appendDirToList(filepath, full_dest_path, options)
                else:
                    self.__appendToList(filepath, dest_path, options)
        except OSError,e:
            error(_("Can't copy %(path)s: %(exception)s") % {'path':dirpath, 'exception':e.strerror})

    def __checkArgs(self, options, source_path, args):
        """Check thats args are files, and add them to copy list"""
        assert(len (args)>=2)
        try:
            dest_path = os.path.normpath(os.path.join(os.path.expanduser(source_path), args.pop()))
        except OSError,e:
            error (_("Invalid dest_path: %s"),e)
        
        for path in args:
            abspath = os.path.normpath(os.path.join(os.path.expanduser(source_path), path))
            if not os.path.exists(abspath):
                warning(_("The path given in arg doesn't exist or is not accessible: %s") % abspath)
            else:
                if os.path.isdir(abspath):
                    full_dest_path = dest_path if os.path.isabs(path) else os.path.normpath(os.path.join(dest_path, path))
                    if not options.recursive:
                        warning (_('omitting directory "%s"') % abspath)
                    else:
                        self.__appendDirToList(abspath, full_dest_path, options)
                else:
                    self.__appendToList(abspath, dest_path, options)

    def __copyNextFile(self):
        """Take the last file in the list, and launch the copy using glib io_watch event
           @return: True a file was added, False else""" 
        if self.copy_list:
            source_file, dest_path, options = self.copy_list.pop()
            self.journal.startFile(source_file)
            source_fd = open(source_file, 'rb')
            filename = os.path.basename(source_file)
            assert(filename)
            dest_file = self.__filename_fix(os.path.join(dest_path,filename),options)
            if os.path.exists(dest_file) and not options.force:
                warning (_("File [%s] already exists, skipping it !") % dest_file)
                return True
            try:
                dest_fd = open(dest_file, 'wb')
            except:
                self.journal.copyFailed()
                self.journal.error("can't open dest")
                self.journal.closeFile()
                source_fd.close()
                return True
                
            gobject.io_add_watch(source_fd,gobject.IO_IN,self._copyFile,
                                 (dest_fd, options), priority=gobject.PRIORITY_HIGH)
            if not self.progress:
                info(_("COPYING %(source)s ==> %(dest)s") % {"source":source_path,"dest":dest_file})
            return True
        else:
            #Nothing left to copy, we quit
            if self.progress:
                self.__pbar_finish()
            self.loop.quit()

    def __copyFailed(self, reason, source_fd, dest_fd):
        """Write the failure in the journal and close files descriptors"""
        self.journal.copyFailed()
        self.journal.error(reason)
        self.journal.closeFile()
        source_fd.close()
        dest_fd.close()
        


    def _copyFile(self, source_fd, condition, data):
        """Actually copy the file, callback used with io_add_watch
        @param source_fd: file descriptor of the file to copy
        @param condition: condition which launched the callback (glib.IO_IN)
        @param data: tuple with (destination file descriptor, copying options)"""
        dest_fd,options = data

        try:
            buff = source_fd.read(self.buffer_size)
        except:
            self.__copyFailed("can't read source", source_fd, dest_fd)
            return False

        try:
            dest_fd.write(buff)
        except:
            self.__copyFailed("can't write to dest", source_fd, dest_fd)
            return False

        self.bytes_copied += len(buff)
        if self.progress:
            self.__pbar_update()

        if len(buff) != self.buffer_size:
            source_fd.close()
            dest_fd.close()
            self.__post_copy(source_fd.name, dest_fd.name, options)
            self.journal.closeFile()
            return False
        return True

    def __filename_fix(self, filename, options):
        """Fix filenames incompatibilities/mistake according to options
        @param filename: full path to the file
        @param options: options as parsed on command line
        @return: fixed filename"""
        fixed_filename = filename

        if self.getFsType(filename) == 'vfat' and options.fs_fix:
            fixed_filename = filename.replace('\\','_')\
                               .replace(':',';')\
                               .replace('*','+')\
                               .replace('?','')\
                               .replace('"','\'')\
                               .replace('<','[')\
                               .replace('>',']')\
                               .replace('|','!')

        if fixed_filename != filename:
            self.journal.error('filename fixed')
        return fixed_filename

    def __post_copy(self, source_file, dest_file, options):
        """Do post copy traitement (mainly managing --preserve option)"""
        st_mode, st_ino, st_dev, st_nlink, st_uid, st_gid, st_size, st_atime, st_mtime, st_ctime = os.stat(source_file)
        #TODO: complete log in case of errors
        for preserve in options.preserve:
            try:
                if preserve == 'mode':
                    os.chmod(dest_file, st_mode)
                elif preserve == 'ownership':
                    os.chown(dest_file, st_uid, st_gid)
                elif preserve == 'timestamps':
                    os.utime(dest_file, (st_atime, st_mtime))
            except OSError,e:
                self.journal.error("preserve-"+preserve)

    def __pbar_update(self):
        """Update progress bar position, create the bar if it doesn't exist"""
        assert(self.progress)
        try:
            if self.pbar.maxval != self.bytes_total:
                self.pbar.maxval = self.bytes_total
        except AttributeError:
            if not self.bytes_total:
                #No progress bar if the files have a null size
                return
            self.pbar = ProgressBar(self.bytes_total,[_("Progress: "),Percentage()," ",Bar()," ",FileTransferSpeed()," ",ETA()])
            self.pbar.start()
        self.pbar.update(self.bytes_copied)

    def __pbar_finish(self):
        """Mark the progression as finished"""
        assert(self.progress)
        try:
            self.pbar.finish()
        except AttributeError:
            pass

    def parseArguments(self, full_args=sys.argv[1:], source_path = os.getcwd()):
        """Parse arguments and add files to queue
        @param full_args: list of arguments strings (without program name)
        @param source_path: path from where the arguments come, ad given by os.getcwd()
        @return: a tuple (boolean, message) where the boolean is the success of the arguments
                 validation, and message is the error message to print when necessary"""
        _usage="""
        %prog [options] FILE1 [FILE2 ...] DEST

        %prog --help for options list
        """
        for idx in range(len(full_args)):
            if isinstance(full_args[idx], unicode):
                #We don't want unicode as some filenames can be invalid unicode
                full_args[idx] = full_args[idx].encode('utf-8')
        
        parser = OptionParser(usage=_usage,version=ABOUT)

        parser.add_option("-r", "--recursive", action="store_true", default=False,
                    help=_("copy directories recursively"))
        
        parser.add_option("-f", "--force", action="store_true", default=False,
                    help=_("force overwriting of existing files"))

        parser.add_option("--preserve", action="store", default='mode,ownership,timestamps',
                    help=_("preserve  the  specified  attributes"))
        
        parser.add_option("--no-unicode-fix", action="store_false", dest='unicode_fix', default=True,
                    help=_("don't fixe name encoding errors")) #TODO

        parser.add_option("--no-fs-fix", action="store_false", dest='fs_fix', default=True,
                    help=_("don't fixe filesystem name incompatibily")) #TODO

        parser.add_option("--no-progress", action="store_false", dest="progress", default=True,
                    help=_("deactivate progress bar"))
        
        parser.add_option("-v", "--verbose", action="store_true", default=False,
                    help=_("Show what is currently done"))
        
        (options, args) = parser.parse_args(full_args)
        #options check
        if options.progress and not pbar_available:
            warning (_("Progress bar is not available, deactivating"))
            options.progress = self.progress = False
        else:
            self.progress = options.progress

        if options.verbose:
            logging.getLogger().setLevel(logging.DEBUG)

        preserve = set(options.preserve.split(','))
        if not preserve.issubset(const_PRESERVE):
            error (_("Invalide --preserve value\nvalid values are:"))
            for value in const_PRESERVE:
                error('- %s' % value)
            exit(2)
        else:
            options.preserve = preserve
        
        #if there is an other instance of gcp, we send options to it
        if not self._main_instance:
            info (_("There is already one instance of %s running, pluging to it") % NAME_SHORT)
            #XXX: we have to serialize data as dbus only accept valid unicode, and filenames
            #     can have invalid unicode.
            return self.gcp_main.addArgs(os.getcwd(),pickle.dumps(full_args))
        else:
            if len(args) < 2:
                _error_msg = _("Wrong number of arguments")
                return (False, _error_msg)
            debug(_("adding args to gcp: %s"),args)
            self.__checkArgs(options, source_path, args)
            self.journal = Journal()
            gobject.idle_add(self.__copyNextFile)
        return (True,'')

    def go(self):
        """Launch main loop"""
        self.loop = gobject.MainLoop()
        try:
            self.loop.run()
        except KeyboardInterrupt:
            info(_("User interruption: good bye"))


if __name__ == "__main__":
    gcp = GCP()
    success,message = gcp.parseArguments()
    if not success:
        error(message)
        exit(1)
    if gcp._main_instance:
        gcp.go()

